---
title: Bzoj 1003(最短路+区间DP)
date: 2017-07-25 16:25
categories:
- Bzoj
tags:
- Bzoj
- 最短路
- 区间DP
---
[BZOJ 1003](http://www.lydsy.com/JudgeOnline/problem.php?id=1003)
这种最优性很难考虑的优先思考DP。
我们可以算出$c(i,j)$为$i$天到$j$天都能走过的最短路。读入不可以走的数据可以存在一个数组里(类似桶)直接查询，然后每次SPFA的时候预处理出哪些点不可以走，之后再做最短路，然后设$dp(i)$为前$i$天的最小费用，则转移方程
$dp(i)=min(dp(j)+c(j+1,i)+k)$
其中初值定为$dp(i)=c(1,i)$，然后本题就解决了，注意$n$和$m$所表示的数量意义，不要把顶点数弄成$n$了。
<!-- more -->
```c++
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#define ms(i, j) memset(i, j, sizeof i)
#define LL long long
#define db double
using namespace std;
const int MAXN = 100 + 5, MAXM = 20 + 5, MAXE = 1000 + 5, INF = 1000000000;
struct node {int u, w;};
struct data {
	int v, w;
}e[MAXE * 2];//no init
int n, m, K, E;//no init
int en, bk[MAXM][MAXN], c[MAXN][MAXN], vi[MAXM], flag[MAXM], dis[MAXM], dp[MAXN];
vector<int> G[MAXM];

void ins(int a, int b, int w) {
	en++, e[en].v = b, e[en].w = w, G[a].push_back(en);
	en++, e[en].v = a, e[en].w = w, G[b].push_back(en);
}
int spfa() {
	for (int i=1;i<=m;i++) dis[i] = INF, vi[i] = false;
	queue<node> q;
	dis[1] = 0, vi[1] = true, q.push((node){1, 0});
	while (!q.empty()) {
		node p = q.front(); q.pop(), vi[p.u] = false;
		for (int i=0;i<G[p.u].size();i++) {
			data orz = e[G[p.u][i]];
			int v = orz.v, w = orz.w;
			if (flag[v] && dis[v] > dis[p.u] + w) {
				dis[v] = dis[p.u] + w;
				if (!vi[v]) q.push((node){v, dis[v]});
			}
		}
	}
	return dis[m];
}
void clean() {
	en = 0;
	for (int i=0;i<=m;i++) {
		G[i].clear();
	}
	ms(c, 0), ms(bk, 0);
}
void solve() {
	clean();
	for (int i=1;i<=E;i++) {
		int a, b, c;
		scanf("%d%d%d", &a, &b, &c), ins(a, b, c);
	}
	int d; scanf("%d", &d);
	while (d--) {
		int P, a, b;
		scanf("%d%d%d", &P, &a, &b);
		for (int i=a;i<=b;i++) bk[P][i] = true;
	}
	for (int i=1;i<=n;i++) {
		for (int j=i;j<=n;j++) {
			
			for (int k=1;k<=m;k++) {
				flag[k] = true;
				for (int l=i;l<=j;l++) {
					if (bk[k][l]) {
						flag[k] = false;
						break;
					}
				}
			}
			
			c[i][j] = spfa();
		}
	}
	for (int i=1;i<=n;i++)
	for (int j=i;j<=n;j++) if (c[i][j] != INF) c[i][j] *= (j - i + 1);
	for (int i=1;i<=n;i++) dp[i] = c[1][i];
	for (int i=1;i<=n;i++) 
	for (int j=1;j<i;j++) dp[i] = min(dp[i], dp[j] + c[j+1][i] + K);
	printf("%d\n", dp[n]);
}
int main() {
	#ifndef ONLINE_JUDGE 
	freopen("1.in", "r", stdin);freopen("1.out", "w", stdout);
	#endif
	scanf("%d%d%d%d", &n, &m, &K, &E), solve();
	return 0;
}
```