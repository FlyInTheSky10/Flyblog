---
title: Bzoj 1612(最短路)
date: 2017-06-21
categories:
- Bzoj
tags:
- Bzoj
- USACO月赛
- 最短路
---
[BZOJ 1612](http://www.lydsy.com/JudgeOnline/problem.php?id=1612)
[Luogu 2419](https://www.luogu.org/problem/show?pid=2888)
from: USACO 2008 Jan Sliver(USACO刷题第16题)

根据题目的胜负关系可以想到要建图建图，然后关键是怎么才能判断出某个点是否可以确定名次
如果一个点和它连通的点的个数为$n-1$，那么这个点一定可以确定名次，正确性显然
数据小，用Floyd传递闭包判连通即可求一个点和它连通的点的个数

<!-- more -->
```c++
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<vector>
#define ms(i, j) memset(i, j, sizeof i)
using namespace std;

const int MAXN = 100 + 5;

int n, m, G[MAXN][MAXN], ans[MAXN];

void clean() {
	ms(G, 0), ms(ans, 0);
}
void init() {
	clean();
	for (int i=1;i<=m;i++) {
		int a, b; scanf("%d%d", &a, &b);
		G[a][b] = 1;
	}
}
void solve() {
	for (int k=1;k<=n;k++)
	for (int i=1;i<=n;i++)
	for (int j=1;j<=n;j++) 
	if (i!=j&&i!=k&&j!=k) G[i][j] = (G[i][j]||(G[i][k]&&G[k][j]));
	
	for (int i=1;i<=n;i++)
	for (int j=1;j<=n;j++) 
	if (G[i][j]) ans[i]++, ans[j]++;
	
	int tot = 0;
	for (int i=1;i<=n;i++) if (ans[i]>=n-1) tot++;
	printf("%d\n", tot);
}
int main() {
	#ifndef ONLINE_JUDGE
	freopen("1.in", "r", stdin);freopen("1.out", "w", stdout);
	#endif
	while (scanf("%d%d", &n, &m)==2) init(), solve();
	return 0;
}
```