---
title: Bzoj 1083(最小瓶颈路)
date: 2017-07-23 16:18
categories:
- Bzoj
tags:
- Bzoj
- 生成树
---
[Bzoj 1083](http://www.lydsy.com/JudgeOnline/problem.php?id=1083)
模板题，第一个答案$n-1$第二个答案边在最小生成树上
注意这里没有给出$m$的范围，那么我们只能按完全图来算最大可能为$\frac{n(n-1)}{2}$
<!-- more -->
```c++
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ms(i, j) memset(i, j, sizeof i)
#define LL long long
#define db double
using namespace std;
const int MAXN = 300 + 5, MAXM = 100000 + 5;
struct data {
	int u, v, wi;
	bool operator < (const data &b) const {
		return wi < b.wi;
	}
}e[MAXM];
int n, m, en, f[MAXN], ans;
int find(int x) {return f[x] == x ? x : f[x] = find(f[x]);}
void clean() {
	en = 0;
	for (int i=1;i<=n;i++) f[i] = i;
}
void solve() {
	clean();
	for (int i=1;i<=m;i++) en++, scanf("%d%d%d", &e[en].u, &e[en].v, &e[en].wi);
	sort(e + 1, e + 1 + m); 
	for (int i=1;i<=m;i++) {
		int x = find(e[i].u), y = find(e[i].v);
		if (x != y) f[x] = y, ans = e[i].wi;
	}
	printf("%d %d\n", n - 1, ans);
}
int main() {
	#ifndef ONLINE_JUDGE 
	freopen("1.in", "r", stdin);freopen("1.out", "w", stdout);
	#endif
	scanf("%d%d", &n, &m), solve();
	return 0;
}
```