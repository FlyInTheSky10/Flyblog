---
title: Bzoj 1634(贪心)
date: 2017-06-16
categories:
- Bzoj
tags:
- Bzoj
- USACO月赛
- 贪心
---
[BZOJ 1634](http://www.lydsy.com/JudgeOnline/problem.php?id=1634)
[Luogu 2878](https://www.luogu.org/problem/show?pid=2878)
from: USACO 2007 Jan Sliver(USACO刷题第11题)

刚开始naive的认为比较函数是第一关键字$d$第二关键字$t$，狂炸的我..

对于两头牛$a, b$，他们的先后顺序不影响其他牛吃花的个数
那么考虑
$a$在$b$前面，那么吃的花为$2*d[b]*t[a]$
$b$在$a$前面，那么吃的花为$2*d[a]*t[b]$
要使$a$在前面吃的花最少，必须满足$d[b]*t[a]  < d[a]*t[b]$
那么放进快排比较函数里就行了，之后贪心
<!-- more -->

```c++
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<stack>
#include<vector>
#define ms(i, j) memset(i, j, sizeof i)
#define LL long long
using namespace std;

const int MAXN = 100000 + 5;

struct data {
	int di, ti;
	bool operator < (const data &b) const {
		return ti*b.di < b.ti*di;
	}
}c[MAXN];
int n;
LL sum, tot;

void clear() {
	tot = sum = 0;
}
void init() {
	clear();
	for (int i=1;i<=n;i++) {
		scanf("%d%d", &c[i].ti, &c[i].di);
		sum += c[i].di;
	}
	sort(c+1, c+1+n);
}
void solve() {
	for (int i=1;i<=n;i++) {
		sum -= c[i].di;
		tot += sum*c[i].ti*2;
	}
	printf("%lld\n", tot);
}
int main() {
	#ifndef ONLINE_JUDGE
	freopen("1.in", "r", stdin);freopen("1.out", "w", stdout);
	#endif
	while (scanf("%d", &n)==1) init(), solve();
	return 0;
}
```