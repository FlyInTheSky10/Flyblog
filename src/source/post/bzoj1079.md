---
title: Bzoj 1079(区间DP+乘法原理)
date: 2017-08-13 21:59
categories:
- Bzoj
tags:
- Bzoj
- 计数原理
- 区间DP
---
[Bzoj 1079](http://www.lydsy.com/JudgeOnline/problem.php?id=1079)
这种题目还是往DP和排列组合想。
直接存颜色用了多少是$5^{15}$的，会炸。我们选择把剩余可涂次数相等的分为一类，考虑因为只要剩余可涂次数相等，那么其实这些颜色并没有什么区别，因为我们涂颜色的时候只需要考虑涂的这种颜色剩余次数即可，并不需要考虑具体是什么颜色（先不考虑相邻颜色不能相等的限制）。
那么令$f(a1, a2, a3, a4, a5)$表示剩余可涂一次的颜色种类数为$a1$，涂二次颜色种类数为$a2$...这样的情况的方案数。
　　显然如果我们当前这次选的是剩余次数为$x$次的颜色，那么剩余次数为$x$次的颜色有多少种，就有多少种情况可以转移过来，只需要乘以数量就可以了（相当于每个格都可以填这些颜色）。
　　但是我们还没考虑相邻不能相等的情况，那么我们必须要少算一次，比如说如果上次填的是颜色剩余次数为2的，意味着颜色中剩余次数为1的多了一个，那么这一次并不能再选这种颜色，这次可以选填1的就要少1。
以上转自[此处](http://www.cnblogs.com/ljh2000-jump/)
<!-- more -->
```c++
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#define ms(i, j) memset(i, j, sizeof i)
#define LL long long
#define db double
using namespace std;
const int MO = 1000000007;
int k, xi[6], mk[16][16][16][16][16][6];
LL dp[16][16][16][16][16][6];
LL dfs(int a1, int a2, int a3, int a4, int a5, int last) {
	if (!(a1 || a2 || a3 || a4 || a5)) return 1;
	if (mk[a1][a2][a3][a4][a5][last]) return dp[a1][a2][a3][a4][a5][last];
	LL tot = 0;
	if (a1) tot = (tot + (a1 - (last == 2)) * dfs(a1 - 1, a2,     a3,     a4,     a5, 1)) % MO;
	if (a2) tot = (tot + (a2 - (last == 3)) * dfs(a1 + 1, a2 - 1, a3,     a4,     a5, 2)) % MO;
	if (a3) tot = (tot + (a3 - (last == 4)) * dfs(a1,     a2 + 1, a3 - 1, a4,     a5, 3)) % MO;
	if (a4) tot = (tot + (a4 - (last == 5)) * dfs(a1,     a2,     a3 + 1, a4 - 1, a5, 4)) % MO;
	if (a5) tot = (tot +  a5                * dfs(a1,     a2,     a3,     a4 + 1, a5 - 1, 5)) % MO;//-(last == x)就是防止两种颜色涂在一起
	mk[a1][a2][a3][a4][a5][last] = true;
	return dp[a1][a2][a3][a4][a5][last] = tot;
}
void clean() {
	ms(mk, false), ms(dp, 0), ms(xi, 0);
}
void solve() {
	clean();
	for (int i=1;i<=k;i++) {
		int x;
		scanf("%d", &x);
		xi[x]++;
	}
	printf("%lld\n", dfs(xi[1], xi[2], xi[3], xi[4], xi[5], 0));
}
int main() {
	#ifndef ONLINE_JUDGE 
	freopen("1.in", "r", stdin);freopen("1.out", "w", stdout);
	#endif
	scanf("%d", &k), solve();
	return 0;
}
```