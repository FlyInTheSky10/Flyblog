---
title: Bzoj 1635(差分序列)
date: 2017-06-17
categories:
- Bzoj
tags:
- Bzoj
- USACO月赛
- 差分序列
- 前缀和
---
[BZOJ 1635](http://www.lydsy.com/JudgeOnline/problem.php?id=1635)
[Luogu 2879](https://www.luogu.org/problem/show?pid=2879)
from: USACO 2007 Jan Sliver(USACO刷题第12题)

之前看完题目想到差分约束，然后是个区间不知道怎么搞。。看完题解是差分序列。。
差分序列和差分约束并不是毫无关系啊。。差分约束运用于两个元素，差分序列运用于区间。。

本题对于每个约束$a,b$，如果$a>b$，显然，交换不会影响结果
我们设$f[i]$为差分序列，然后对于每个约束$a,b$，我们使$f[a+1]--, f[b]++$，这样可以保证$a,b$之间的元素严格小于$a,b$
之后前缀和加上最高高度即可。前缀和一定不会大于$0$，因为每次操作都是在左边$-1$，右边$+1$
本题可能会有重复的约束，要排序以后去重(考试的时候一定要注意这种问题)
<!-- more -->
```c++
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<stack>
#include<vector>
#define ms(i, j) memset(i, j, sizeof i)
#define LL long long
using namespace std;

const int MAXN = 10000 + 5;

struct data {
	int l, r;
	bool operator < (const data &b) const {
		if (l==b.l) return r < b.r;
		return l < b.l;
	}
}d[MAXN];
int f[MAXN], n, m, q;

void clear() {
	ms(f, 0);
}
void init() {
	clear();
	for (int i=1;i<=q;i++) {
		scanf("%d%d", &d[i].l, &d[i].r);
		if (d[i].l>d[i].r) swap(d[i].l, d[i].r);
	}
}
void solve() {
	for (int i=1;i<=q;i++) {
		if (i!=1&&d[i].l==d[i-1].l&&d[i].r==d[i-1].r) continue;
		f[d[i].l+1]--, f[d[i].r]++;
	}
	for (int i=1;i<=n;i++) f[i] += f[i-1];
	for (int i=1;i<=n;i++) printf("%d\n", f[i]+m);
}
int main() {
	#ifndef ONLINE_JUDGE
	freopen("1.in", "r", stdin);freopen("1.out", "w", stdout);
	#endif
	while (scanf("%d%d%d%d", &n, &m, &m, &q)==4) init(), solve();
	return 0;
}
```